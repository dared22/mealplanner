---
phase: 08-personalization-ui
plan: 02
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - Backend/fastapi_app/main.py
  - Frontend/src/components/questionnaire/ResultsStep.jsx
autonomous: true

must_haves:
  truths:
    - "User can see why a meal was recommended via info icon"
    - "Explainability shows simple reasoning like 'You liked 5 Italian dishes'"
    - "Plan view indicates whether plan was AI-generated or personalized"
    - "User can view their past meal plans"
  artifacts:
    - path: "Backend/fastapi_app/main.py"
      provides: "Explainability data in preferences response"
      contains: "recommendation_reasons"
    - path: "Frontend/src/components/questionnaire/ResultsStep.jsx"
      provides: "Explainability tooltip and generation source badge"
  key_links:
    - from: "ResultsStep.jsx"
      to: "generation_source field"
      via: "plan prop containing generation_source"
      pattern: "generation_source"
---

<objective>
Add explainability features and generation source indicator to the meal plan UI

Purpose: Help users understand why meals were recommended and whether their plan was personalized or AI-generated
Output: Info icons with explainability tooltips, generation source badge, and plan history view capability
</objective>

<execution_context>
@/Users/pasha/.claude/get-shit-done/workflows/execute-plan.md
@/Users/pasha/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-rating-infrastructure/06-01-SUMMARY.md
@.planning/phases/07-constraint-solver-engine/07-02-SUMMARY.md
@Backend/fastapi_app/main.py
@Backend/fastapi_app/models.py
@Frontend/src/components/questionnaire/ResultsStep.jsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add explainability data to backend response</name>
  <files>Backend/fastapi_app/main.py</files>
  <action>
Enhance the GET /preferences/{pref_id} response to include recommendation reasoning:

1. Create helper function to generate explainability data:
```python
def _generate_recommendation_reasons(
    db: Session,
    user_id: UUID,
    plan: Dict[str, Any]
) -> Dict[str, Any]:
    """
    Generate simple explanation for why meals were recommended.
    Returns dict with:
    - summary: Overall explanation (e.g., "Based on your 15 ratings")
    - cuisine_preferences: Dict of cuisine -> count of liked recipes
    - top_liked_tags: List of most common tags in liked recipes
    """
    # Get user's liked recipes
    liked_ratings = db.scalars(
        select(Rating)
        .where(Rating.user_id == user_id, Rating.is_liked == True)
    ).all()

    if not liked_ratings:
        return {
            "summary": "Optimized for your nutritional goals",
            "cuisine_preferences": {},
            "top_liked_tags": []
        }

    # Get recipe details for liked recipes
    liked_ids = [r.recipe_id for r in liked_ratings]
    liked_recipes = db.scalars(
        select(Recipe)
        .where(Recipe.id.in_(liked_ids))
    ).all()

    # Count cuisines
    cuisine_counts = {}
    tag_counts = {}
    for recipe in liked_recipes:
        if recipe.cuisine:
            cuisine_counts[recipe.cuisine] = cuisine_counts.get(recipe.cuisine, 0) + 1
        if recipe.tags:
            for tag in recipe.tags:
                tag_counts[tag] = tag_counts.get(tag, 0) + 1

    # Sort by count
    top_cuisines = dict(sorted(cuisine_counts.items(), key=lambda x: -x[1])[:3])
    top_tags = sorted(tag_counts.items(), key=lambda x: -x[1])[:5]

    # Generate summary
    total_liked = len(liked_ratings)
    if top_cuisines:
        top_cuisine = list(top_cuisines.keys())[0]
        top_count = top_cuisines[top_cuisine]
        summary = f"Based on {total_liked} ratings - you liked {top_count} {top_cuisine} dishes"
    else:
        summary = f"Based on your {total_liked} ratings"

    return {
        "summary": summary,
        "cuisine_preferences": top_cuisines,
        "top_liked_tags": [tag for tag, _ in top_tags]
    }
```

2. Update the GET /preferences/{pref_id} endpoint to include explainability:
   - After getting the preference, call _generate_recommendation_reasons
   - Add "recommendation_reasons" to the response dict
   - Only generate if plan_status is "success" and generation_source is "solver"

3. Find the response building section in GET /preferences/{pref_id} (around line 1710-1725) and add:
```python
# Add recommendation reasons for solver-generated plans
recommendation_reasons = None
if plan_status == "success" and generation_source == "solver":
    recommendation_reasons = _generate_recommendation_reasons(db, current_user.id, generated_plan)

# Include in response dict
"recommendation_reasons": recommendation_reasons,
```
  </action>
  <verify>
Test the endpoint:
```bash
# For a user with 10+ ratings and a solver-generated plan
curl -X GET "http://localhost:8000/preferences/{pref_id}" -H "Authorization: Bearer $TOKEN"
```
Response should include:
- "generation_source": "solver"
- "recommendation_reasons": { "summary": "Based on X ratings...", "cuisine_preferences": {...}, "top_liked_tags": [...] }
  </verify>
  <done>
Preferences endpoint returns recommendation_reasons with summary, cuisine preferences, and top tags for solver-generated plans
  </done>
</task>

<task type="auto">
  <name>Task 2: Add generation source badge and explainability UI</name>
  <files>Frontend/src/components/questionnaire/ResultsStep.jsx</files>
  <action>
Add generation source indicator and meal explainability tooltips to ResultsStep:

1. Update ResultsStep props to accept generation source and recommendation reasons:
```javascript
export default function ResultsStep({
  data,
  plan,
  rawPlanText,
  status = 'idle',
  generationStage: currentGenerationStage = null,
  generationSource = null,  // Add this
  recommendationReasons = null,  // Add this
  errorMessage,
  onRegenerate,
  regenerateDisabled = false,
  onRestart
}) {
```

2. Create GenerationBadge component:
```jsx
const GenerationBadge = memo(function GenerationBadge({ source, t }) {
  const translate = t || ((v) => v);

  if (!source) return null;

  const isPersonalized = source === 'solver';
  const label = isPersonalized
    ? translate('Personalized Plan')
    : translate('AI Generated');
  const description = isPersonalized
    ? translate('Optimized based on your ratings')
    : translate('Generated by AI based on your goals');

  return (
    <div className={`inline-flex items-center gap-2 px-3 py-1.5 rounded-full text-xs font-medium ${
      isPersonalized
        ? 'bg-green-100 text-green-800 dark:bg-green-900/30 dark:text-green-200'
        : 'bg-blue-100 text-blue-800 dark:bg-blue-900/30 dark:text-blue-200'
    }`}>
      {isPersonalized ? (
        <Sparkles className="w-3.5 h-3.5" />
      ) : (
        <Wand2 className="w-3.5 h-3.5" />
      )}
      <span>{label}</span>
      <span className="hidden sm:inline text-muted-foreground">
        â€” {description}
      </span>
    </div>
  );
});
```

3. Create ExplainabilityTooltip component for meals:
```jsx
const ExplainabilityTooltip = memo(function ExplainabilityTooltip({ reasons, t }) {
  const translate = t || ((v) => v);
  const [isOpen, setIsOpen] = useState(false);

  if (!reasons) return null;

  return (
    <div className="relative">
      <button
        type="button"
        onClick={() => setIsOpen(!isOpen)}
        className="meal-action text-muted-foreground hover:text-primary"
        title={translate('Why this meal?')}
      >
        <Info className="w-4 h-4" />
      </button>

      {isOpen && (
        <Motion.div
          initial={{ opacity: 0, y: -5 }}
          animate={{ opacity: 1, y: 0 }}
          className="absolute right-0 top-full mt-2 w-64 p-3 rounded-lg bg-popover border border-border shadow-lg z-20"
        >
          <p className="text-sm font-medium mb-2">{translate('Why this recommendation?')}</p>
          <p className="text-xs text-muted-foreground mb-2">{reasons.summary}</p>

          {reasons.cuisine_preferences && Object.keys(reasons.cuisine_preferences).length > 0 && (
            <div className="text-xs text-muted-foreground">
              <span className="font-medium">{translate('Your favorites')}: </span>
              {Object.entries(reasons.cuisine_preferences)
                .map(([cuisine, count]) => `${cuisine} (${count})`)
                .join(', ')}
            </div>
          )}

          <button
            onClick={() => setIsOpen(false)}
            className="absolute top-2 right-2 text-muted-foreground hover:text-foreground"
          >
            <X className="w-3 h-3" />
          </button>
        </Motion.div>
      )}
    </div>
  );
});
```

4. Update MealItem component to include explainability icon:
```jsx
const MealItem = memo(function MealItem({
  meal,
  mealType,
  onSwap,
  t,
  recipeRating,
  onRate,
  ratingDisabled,
  recommendationReasons  // Add this prop
}) {
  // ... existing code ...

  // Add after the existing action buttons, before the rating buttons:
  {recommendationReasons && (
    <ExplainabilityTooltip reasons={recommendationReasons} t={t} />
  )}
```

5. Add GenerationBadge to the hero section (after the headline):
```jsx
{/* After the headline h1, before the paragraph */}
{isReady && generationSource && (
  <div className="mt-4 flex justify-center">
    <GenerationBadge source={generationSource} t={t} />
  </div>
)}
```

6. Pass recommendationReasons to MealItem components:
```jsx
<MealItem
  key={`${selectedDay.name}-${mealType}`}
  meal={selectedDay.meals[mealType]}
  mealType={mealType}
  onSwap={() => handleSwap(selectedDayIndex, mealType)}
  t={t}
  recipeRating={getRating(selectedDay.meals[mealType]?.id)}
  onRate={submitRating}
  ratingDisabled={ratingLoading}
  recommendationReasons={recommendationReasons}  // Add this
/>
```

7. Import additional icons from lucide-react:
```javascript
import { ..., Sparkles, Wand2 } from 'lucide-react';
```

8. Update MealPlanner.jsx to pass new props to ResultsStep:
   - The MealPlanner already fetches preference data that includes generation_source
   - Add recommendationReasons to the polling response handling
   - Pass generationSource and recommendationReasons as props to ResultsStep
  </action>
  <verify>
1. Generate a new meal plan (or use existing)
2. Check that generation badge appears below headline:
   - "Personalized Plan - Optimized based on your ratings" for solver plans
   - "AI Generated - Generated by AI based on your goals" for OpenAI plans
3. Click info icon on a meal item
4. Tooltip should show: "Why this recommendation?" with summary and cuisine preferences
5. Tooltip should be dismissible
  </verify>
  <done>
Generation source badge displays correctly, and meals have info icons showing explainability tooltips with personalization reasoning
  </done>
</task>

<task type="auto">
  <name>Task 3: Update MealPlanner to pass new props</name>
  <files>Frontend/src/Pages/MealPlanner.jsx</files>
  <action>
Update MealPlanner.jsx to extract and pass generation_source and recommendation_reasons to ResultsStep:

1. Add state for new fields:
```javascript
const [generationSource, setGenerationSource] = useState(null);
const [recommendationReasons, setRecommendationReasons] = useState(null);
```

2. Update the polling/fetch logic where preference data is received (look for where `generated_plan` or `plan_status` is handled):
```javascript
// After receiving preference response:
if (data.generation_source) {
  setGenerationSource(data.generation_source);
}
if (data.recommendation_reasons) {
  setRecommendationReasons(data.recommendation_reasons);
}
```

3. Reset these states when generating a new plan:
```javascript
// When starting new generation:
setGenerationSource(null);
setRecommendationReasons(null);
```

4. Pass props to ResultsStep:
```jsx
<ResultsStep
  // ... existing props
  generationSource={generationSource}
  recommendationReasons={recommendationReasons}
/>
```
  </action>
  <verify>
1. Generate a new plan as a user with 10+ ratings
2. After plan loads, verify generationSource state is "solver"
3. Verify recommendationReasons contains summary and cuisine_preferences
4. Check ResultsStep receives these props via React DevTools or console.log
  </verify>
  <done>
MealPlanner extracts generation_source and recommendation_reasons from API and passes to ResultsStep
  </done>
</task>

</tasks>

<verification>
1. Generation source badge appears for both AI and personalized plans
2. Info icon on meals shows explainability tooltip
3. Tooltip displays "Based on X ratings - you liked Y Italian dishes" style text
4. Tooltip shows cuisine preferences if available
5. OpenAI-generated plans show "AI Generated" badge
6. Solver-generated plans show "Personalized Plan" badge
7. All existing functionality (ratings, swap) continues to work
</verification>

<success_criteria>
- Generation source badge visible on all plan results
- Explainability tooltip accessible via info icon
- Tooltip content reflects actual user ratings data
- No console errors or performance degradation
</success_criteria>

<output>
After completion, create `.planning/phases/08-personalization-ui/08-02-SUMMARY.md`
</output>
