---
phase: 08-personalization-ui
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Backend/fastapi_app/main.py
  - Frontend/src/components/questionnaire/ResultsStep.jsx
autonomous: true

must_haves:
  truths:
    - "User can click swap on a meal and see 3-5 alternative recipes"
    - "Alternatives match the same meal type (breakfast/lunch/dinner)"
    - "Alternatives respect user's dietary restrictions"
    - "Swap interface loads in under 2 seconds"
    - "Selecting an alternative replaces the meal in the plan view"
  artifacts:
    - path: "Backend/fastapi_app/main.py"
      provides: "GET /recipes/alternatives/{recipe_id} endpoint"
      contains: "alternatives"
    - path: "Frontend/src/components/questionnaire/ResultsStep.jsx"
      provides: "SwapModal component with alternative recipes"
  key_links:
    - from: "ResultsStep.jsx"
      to: "/recipes/alternatives/{recipe_id}"
      via: "fetch in SwapModal when opened"
      pattern: "recipes/alternatives"
---

<objective>
Add backend endpoint for fetching alternative meals and frontend swap modal UI

Purpose: Enable users to swap individual meals with suitable alternatives that match their dietary preferences and meal type requirements
Output: Working meal swap feature with backend API and frontend modal
</objective>

<execution_context>
@/Users/pasha/.claude/get-shit-done/workflows/execute-plan.md
@/Users/pasha/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-rating-infrastructure/06-01-SUMMARY.md
@.planning/phases/07-constraint-solver-engine/07-01-SUMMARY.md
@Backend/fastapi_app/main.py
@Backend/fastapi_app/models.py
@Frontend/src/components/questionnaire/ResultsStep.jsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add alternatives endpoint to backend</name>
  <files>Backend/fastapi_app/main.py</files>
  <action>
Add `GET /recipes/alternatives/{recipe_id}` endpoint that:

1. Takes recipe_id as path parameter and optional query params:
   - `meal_type` (string, optional): Filter by meal type if the source recipe doesn't have one
   - `limit` (int, default=5, max=10): Number of alternatives to return

2. Implementation logic:
   - Fetch the source recipe by ID to get its meal_type
   - If recipe not found or inactive, return 404
   - Get current user's dietary restrictions from their most recent preference
   - Get user's disliked recipe IDs from Rating table
   - Query Recipe table for alternatives:
     - Same meal_type (breakfast/lunch/dinner/snack) OR match provided meal_type param
     - is_active = True
     - Not the source recipe
     - Not in user's disliked set
     - Respects dietary restrictions (same filter logic as solver: vegan, vegetarian, gluten_free, dairy_free, nut_free)
   - Order by: liked recipes first (if any), then popularity_score desc, then random
   - Limit to requested count

3. Response model (create Pydantic models):
```python
class AlternativeRecipe(BaseModel):
    id: UUID
    title: str
    calories: int
    protein: float
    carbs: float
    fat: float
    cook_time: Optional[str] = None
    is_liked: bool = False  # Whether user has liked this recipe

class AlternativesResponse(BaseModel):
    alternatives: List[AlternativeRecipe]
    source_recipe_id: UUID
    meal_type: str
```

4. Add endpoint after the existing `/recipes` endpoint (around line 2545)

NOTE: Do NOT use a subquery for liked_recipe_ids check in the main query - instead:
- First fetch liked_recipe_ids into a Python set
- Filter in Python or use a simple `IN` clause if needed
- This avoids complex nested query issues
  </action>
  <verify>
Start backend server and test:
```bash
curl -X GET "http://localhost:8000/recipes/alternatives/{recipe_id}?limit=5" -H "Authorization: Bearer $TOKEN"
```
Should return 200 with alternatives array containing 3-5 recipes matching meal type.
  </verify>
  <done>
Endpoint returns alternative recipes filtered by meal type and dietary restrictions in under 2 seconds
  </done>
</task>

<task type="auto">
  <name>Task 2: Add swap modal UI to ResultsStep</name>
  <files>Frontend/src/components/questionnaire/ResultsStep.jsx</files>
  <action>
Modify ResultsStep.jsx to add a SwapModal component and wire it to the backend:

1. Add state for swap modal:
```javascript
const [swapModal, setSwapModal] = useState({ open: false, dayIndex: null, mealType: null, recipeId: null });
const [alternatives, setAlternatives] = useState([]);
const [loadingAlternatives, setLoadingAlternatives] = useState(false);
```

2. Create SwapModal component (inside ResultsStep.jsx or extract to separate file):
```jsx
const SwapModal = memo(function SwapModal({ isOpen, onClose, alternatives, loading, onSelect, currentMeal, t }) {
  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/50" onClick={onClose}>
      <Motion.div
        initial={{ opacity: 0, scale: 0.95 }}
        animate={{ opacity: 1, scale: 1 }}
        className="bg-card rounded-2xl p-6 w-full max-w-lg mx-4 max-h-[80vh] overflow-y-auto"
        onClick={(e) => e.stopPropagation()}
      >
        <div className="flex justify-between items-center mb-4">
          <h3 className="text-lg font-semibold">{t('Swap Meal')}</h3>
          <button onClick={onClose} className="btn-icon">
            <X className="w-5 h-5" />
          </button>
        </div>

        {loading ? (
          <div className="flex items-center justify-center py-8">
            <RefreshCw className="w-6 h-6 animate-spin text-primary" />
          </div>
        ) : alternatives.length === 0 ? (
          <p className="text-center py-8 text-muted-foreground">
            {t('No alternatives found matching your preferences')}
          </p>
        ) : (
          <div className="space-y-3">
            {alternatives.map((alt) => (
              <button
                key={alt.id}
                onClick={() => onSelect(alt)}
                className="w-full p-4 rounded-xl border border-border hover:border-primary hover:bg-accent transition-colors text-left"
              >
                <div className="flex justify-between items-start">
                  <div>
                    <h4 className="font-medium">{alt.title}</h4>
                    <div className="text-sm text-muted-foreground mt-1">
                      {alt.calories} kcal • P{alt.protein}g • C{alt.carbs}g • F{alt.fat}g
                    </div>
                  </div>
                  {alt.is_liked && (
                    <ThumbsUp className="w-4 h-4 text-green-500 fill-current" />
                  )}
                </div>
              </button>
            ))}
          </div>
        )}
      </Motion.div>
    </div>
  );
});
```

3. Add fetchAlternatives function:
```javascript
const fetchAlternatives = useCallback(async (recipeId, mealType) => {
  if (!recipeId) return;
  setLoadingAlternatives(true);
  try {
    const token = await getToken();
    const apiUrl = import.meta.env.VITE_API_URL || 'http://localhost:8000';
    const url = `${apiUrl}/recipes/alternatives/${recipeId}?meal_type=${mealType.toLowerCase()}&limit=5`;
    const res = await fetch(url, {
      headers: { Authorization: `Bearer ${token}` }
    });
    if (res.ok) {
      const data = await res.json();
      setAlternatives(data.alternatives || []);
    } else {
      setAlternatives([]);
    }
  } catch (err) {
    console.error('Failed to fetch alternatives:', err);
    setAlternatives([]);
  } finally {
    setLoadingAlternatives(false);
  }
}, []);
```

4. Update handleSwap to open modal instead of random swap:
```javascript
const handleSwap = useCallback((dayIndex, mealType) => {
  const meal = displayPlan?.days?.[dayIndex]?.meals?.[mealType];
  if (!meal?.id) {
    // Fallback to random swap if no recipe ID (old behavior)
    // ... existing random swap logic
    return;
  }
  setSwapModal({ open: true, dayIndex, mealType, recipeId: meal.id });
  fetchAlternatives(meal.id, mealType);
}, [displayPlan, fetchAlternatives]);
```

5. Add handleSelectAlternative function:
```javascript
const handleSelectAlternative = useCallback((alt) => {
  const { dayIndex, mealType } = swapModal;
  setPlanOverrides((prev) => ({
    ...prev,
    [dayIndex]: {
      ...(prev[dayIndex] || {}),
      [mealType]: {
        id: alt.id,
        name: alt.title,
        calories: alt.calories,
        protein: alt.protein,
        carbs: alt.carbs,
        fat: alt.fat,
        cookTime: alt.cook_time || '20 min',
        ingredients: [],
        instructions: ''
      }
    }
  }));
  setSwapModal({ open: false, dayIndex: null, mealType: null, recipeId: null });
}, [swapModal]);
```

6. Add SwapModal to render (after the existing content):
```jsx
<SwapModal
  isOpen={swapModal.open}
  onClose={() => setSwapModal({ open: false, dayIndex: null, mealType: null, recipeId: null })}
  alternatives={alternatives}
  loading={loadingAlternatives}
  onSelect={handleSelectAlternative}
  currentMeal={swapModal.recipeId}
  t={t}
/>
```

7. Import X icon from lucide-react (add to existing import):
```javascript
import { ..., X } from 'lucide-react';
```

8. Import useAuth hook from Clerk for getToken:
```javascript
import { useAuth } from '@clerk/clerk-react';
```
And add to component:
```javascript
const { getToken } = useAuth();
```
  </action>
  <verify>
1. Start frontend: `npm run dev`
2. Navigate to a generated meal plan
3. Click swap button on any meal
4. Modal should open, show loading spinner briefly, then display 3-5 alternatives
5. Click an alternative to swap - meal should update in the plan view
6. Close modal by clicking outside or X button
  </verify>
  <done>
Swap modal opens with alternatives fetched from backend, user can select an alternative to replace the meal
  </done>
</task>

</tasks>

<verification>
1. Backend endpoint returns alternatives in <2 seconds
2. Alternatives match meal type of source recipe
3. Alternatives respect dietary restrictions
4. Disliked recipes are excluded from alternatives
5. Modal shows loading state then alternatives
6. Selecting alternative updates the plan view
7. Modal can be closed without selecting
</verification>

<success_criteria>
- GET /recipes/alternatives/{recipe_id} returns 3-5 filtered alternatives
- Swap modal displays alternatives with nutrition info
- Users can select alternative to replace meal in plan
- No regressions to existing rating functionality
</success_criteria>

<output>
After completion, create `.planning/phases/08-personalization-ui/08-01-SUMMARY.md`
</output>
