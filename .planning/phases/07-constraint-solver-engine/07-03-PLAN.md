---
phase: 07-constraint-solver-engine
plan: 03
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - Frontend/src/components/questionnaire/ResultsStep.jsx
  - Backend/fastapi_app/main.py
autonomous: true

must_haves:
  truths:
    - "User sees stage-based progress during plan generation"
    - "Progress shows 'Finding recipes...', 'Optimizing nutrition...', 'Finalizing plan...'"
    - "Extended message appears after 10 seconds: 'This is taking longer than usual, almost done...'"
    - "Progress feedback works for both solver and OpenAI generation paths"
  artifacts:
    - path: "Frontend/src/components/questionnaire/ResultsStep.jsx"
      provides: "Stage-based progress UI during plan generation"
      contains: "generationStage"
    - path: "Backend/fastapi_app/main.py"
      provides: "Generation status endpoint with stage info"
      contains: "generation_stage"
  key_links:
    - from: "Frontend/src/components/questionnaire/ResultsStep.jsx"
      to: "/preferences/{id}"
      via: "polling for plan status"
      pattern: "fetch.*preferences"
---

<objective>
Add stage-based progress feedback during meal plan generation to improve UX and reassure users during the 10-15 second generation time.

Purpose: User experience improvement - per CONTEXT.md, show stages not percentages, add extended message after 10s
Output: Frontend progress UI with stages, backend endpoint updates to track generation stage
</objective>

<execution_context>
@/Users/pasha/.claude/get-shit-done/workflows/execute-plan.md
@/Users/pasha/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-constraint-solver-engine/07-CONTEXT.md
@Frontend/src/components/questionnaire/ResultsStep.jsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add generation stage tracking to backend</name>
  <files>Backend/fastapi_app/main.py</files>
  <action>
Add stage tracking to the plan generation process so frontend can display meaningful progress.

1. **Add generation stage to preference raw_data:**

Modify `_generate_plan_in_background` to update stage during generation:

```python
def _update_generation_stage(db: Session, pref_id: int, stage: str) -> None:
    """Update the generation stage for frontend progress display."""
    preference = db.get(Preference, pref_id)
    if preference is None:
        return

    raw_data = dict(preference.raw_data) if isinstance(preference.raw_data, dict) else {}
    raw_data["generation_stage"] = stage
    raw_data["generation_stage_updated_at"] = datetime.now(timezone.utc).isoformat()
    preference.raw_data = raw_data
    db.add(preference)
    db.commit()
```

2. **Add stage updates throughout generation:**

At start of `_generate_plan_in_background`:
```python
_update_generation_stage(db, pref_id, "finding_recipes")
```

After macro goal generation (in both solver and OpenAI paths):
```python
_update_generation_stage(db, pref_id, "optimizing_nutrition")
```

Before final result storage:
```python
_update_generation_stage(db, pref_id, "finalizing")
```

On completion (in `_persist_plan_result`):
```python
# Clear stage on completion
if "generation_stage" in updated_raw:
    del updated_raw["generation_stage"]
if "generation_stage_updated_at" in updated_raw:
    del updated_raw["generation_stage_updated_at"]
```

3. **Expose stage in GET /preferences/{pref_id} response:**

Add to the response dict building:
```python
generation_stage = None
generation_stage_updated_at = None
if plan_status == "pending":
    generation_stage = raw_data.get("generation_stage", "finding_recipes")
    generation_stage_updated_at = raw_data.get("generation_stage_updated_at")

return {
    # ... existing fields ...
    "generation_stage": generation_stage,
    "generation_stage_updated_at": generation_stage_updated_at,
}
```

The stages are:
- `finding_recipes` - Initial stage, loading data
- `optimizing_nutrition` - Running solver or calling OpenAI
- `finalizing` - Building final plan structure
- `null` - Complete (plan_status != pending)
  </action>
  <verify>
Test GET /preferences/{id} returns generation_stage when plan_status is "pending"
  </verify>
  <done>
Backend tracks and exposes generation_stage during plan generation
  </done>
</task>

<task type="auto">
  <name>Task 2: Add stage-based progress UI to frontend</name>
  <files>Frontend/src/components/questionnaire/ResultsStep.jsx</files>
  <action>
Update ResultsStep to show stage-based progress during plan generation.

1. **Add stage state and messages:**

```jsx
const GENERATION_STAGES = {
  finding_recipes: "Finding recipes...",
  optimizing_nutrition: "Optimizing nutrition...",
  finalizing: "Finalizing plan...",
};

// In component state
const [generationStage, setGenerationStage] = useState(null);
const [generationStartTime, setGenerationStartTime] = useState(null);
const [showExtendedMessage, setShowExtendedMessage] = useState(false);
```

2. **Update polling to track stage and elapsed time:**

In the existing useEffect that polls for plan status:

```jsx
useEffect(() => {
  if (!preferenceId) return;

  // Track when generation started
  if (!generationStartTime && plan_status === "pending") {
    setGenerationStartTime(Date.now());
  }

  const poll = async () => {
    const response = await fetch(`${API_URL}/preferences/${preferenceId}?lang=${lang}`, {
      headers: { Authorization: `Bearer ${token}` },
    });
    const data = await response.json();

    // Update stage
    if (data.generation_stage) {
      setGenerationStage(data.generation_stage);
    }

    // Check for extended message (>10 seconds)
    if (generationStartTime && Date.now() - generationStartTime > 10000) {
      setShowExtendedMessage(true);
    }

    // ... existing plan status handling ...
  };

  const interval = setInterval(poll, 1500);
  return () => clearInterval(interval);
}, [preferenceId, generationStartTime, ...]);
```

3. **Update loading UI to show stages:**

Replace the existing loading spinner/message with:

```jsx
{planStatus === "pending" && (
  <div className="flex flex-col items-center justify-center py-8">
    <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-primary mb-4" />
    <p className="text-lg font-medium text-gray-700">
      {GENERATION_STAGES[generationStage] || "Preparing your meal plan..."}
    </p>
    {showExtendedMessage && (
      <p className="text-sm text-gray-500 mt-2">
        This is taking longer than usual, almost done...
      </p>
    )}
  </div>
)}
```

4. **Reset state on new generation:**

When user submits new preferences:
```jsx
setGenerationStage(null);
setGenerationStartTime(null);
setShowExtendedMessage(false);
```
  </action>
  <verify>
Visual review: During plan generation, user should see:
1. "Finding recipes..." initially
2. "Optimizing nutrition..." during main generation
3. "Finalizing plan..." near completion
4. "This is taking longer than usual, almost done..." after 10 seconds
  </verify>
  <done>
Frontend shows stage-based progress with extended message after 10 seconds
  </done>
</task>

</tasks>

<verification>
After completing all tasks:

1. Backend verification:
   - [ ] GET /preferences/{id} returns generation_stage when pending
   - [ ] Stage transitions: finding_recipes -> optimizing_nutrition -> finalizing -> null

2. Frontend verification:
   - [ ] Loading UI shows current stage message
   - [ ] Extended message appears after 10 seconds
   - [ ] Stage resets on new preference submission

3. End-to-end flow:
   - Submit new preferences
   - Observe stage progression in UI
   - Wait 10+ seconds to see extended message (if generation is slow)
</verification>

<success_criteria>
- Stage-based progress replaces generic spinner
- Three stages shown sequentially during generation
- Extended message after 10 seconds reassures user
- Clean transitions without flickering
- Works for both solver and OpenAI generation paths
</success_criteria>

<output>
After completion, create `.planning/phases/07-constraint-solver-engine/07-03-SUMMARY.md`
</output>
