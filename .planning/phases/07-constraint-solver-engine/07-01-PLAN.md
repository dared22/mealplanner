---
phase: 07-constraint-solver-engine
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Backend/fastapi_app/solver.py
  - Backend/fastapi_app/requirements.txt
autonomous: true

must_haves:
  truths:
    - "Solver generates 21 meals (7 days x 3 meals) respecting dietary restrictions"
    - "Liked recipes are preferred over neutral recipes in the solution"
    - "Macros stay within ±10% tolerance of daily targets"
    - "Each recipe appears at most once per week (21 unique preferred)"
    - "If insufficient unique recipes, allow max 1 recipe to appear twice"
    - "Solver completes or times out within 10 seconds"
    - "Food group diversity: solver distributes meals across food categories (deferred to Phase 8 - not in user decisions)"
  artifacts:
    - path: "Backend/fastapi_app/solver.py"
      provides: "Constraint solver module for personalized meal plans"
      exports: ["generate_personalized_plan"]
      min_lines: 200
    - path: "Backend/fastapi_app/requirements.txt"
      provides: "PuLP dependency for constraint optimization"
      contains: "pulp"
  key_links:
    - from: "Backend/fastapi_app/solver.py"
      to: "models.py"
      via: "imports Rating, Recipe, PlanRecipe"
      pattern: "from models import"
---

<objective>
Build the constraint solver that generates personalized weekly meal plans optimizing for user preferences (liked recipes), macro nutritional targets, and dietary restrictions.

Purpose: Core algorithm for personalized meal plan generation - the heart of v1.1 personalization
Output: `solver.py` module with `generate_personalized_plan()` function that can replace OpenAI generation for users with 10+ ratings
</objective>

<execution_context>
@/Users/pasha/.claude/get-shit-done/workflows/execute-plan.md
@/Users/pasha/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-constraint-solver-engine/07-CONTEXT.md
@Backend/fastapi_app/models.py
@Backend/fastapi_app/planner.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add PuLP dependency</name>
  <files>Backend/fastapi_app/requirements.txt</files>
  <action>
Add the PuLP library for linear programming / constraint optimization:

1. Add `pulp>=2.7.0` to requirements.txt
2. Install locally to verify: `pip install pulp`

PuLP was chosen over OR-Tools because:
- Simpler API for linear/integer programming
- Lighter weight dependency
- Sufficient for meal plan optimization (selection problem, not complex scheduling)
  </action>
  <verify>Run `pip install -r requirements.txt` - should complete without errors</verify>
  <done>PuLP is listed in requirements.txt and installs successfully</done>
</task>

<task type="auto">
  <name>Task 2: Create constraint solver module</name>
  <files>Backend/fastapi_app/solver.py</files>
  <action>
Create `solver.py` with the personalized meal plan generator. Use PuLP for the optimization.

**Function signature:**
```python
def generate_personalized_plan(
    db: Session,
    user_id: UUID,
    preference: Preference,
    timeout_seconds: int = 10,
) -> Dict[str, Any]:
    """
    Generate a personalized weekly meal plan using constraint optimization.

    Returns dict with keys:
    - plan: The meal plan structure (same format as OpenAI planner)
    - error: Error message if generation failed
    - fallback_reason: Why solver couldn't complete (for logging)
    - quality_metrics: Dict with liked_ratio, macro_deviation for monitoring
    """
```

**Algorithm overview:**

1. **Load data:**
   - User ratings from Rating model (get liked/disliked recipe IDs)
   - User's last week's plan from PlanRecipe model (to avoid repeats)
     - Query: Find most recent Preference for user_id with plan_status="success"
     - Get PlanRecipe entries for that preference_id
     - Extract recipe_ids to exclude set
   - Active recipes from Recipe model filtered by dietary restrictions
   - Macro targets from preference (generate via existing `generate_daily_macro_goal`)

2. **Pre-filter recipes (SOLVER-09: 300-500 candidates):**
   - Filter by dietary restrictions (hard constraint - eliminate recipes that violate)
   - Filter by budget tier (soft preference - if too few recipes remain, relax)
   - Filter by cooking time preference (soft preference - same relaxation)
   - Exclude disliked recipes entirely
   - Exclude last week's recipes (from PlanRecipe)
   - Keep liked recipes + neutral recipes up to ~500 total

3. **Build optimization model:**
   - Decision variables: binary x[recipe_id, day, meal_type] = 1 if recipe selected
   - For each (day, meal_type): exactly 1 recipe selected (21 slots total)
   - Hard constraint: dietary restrictions already handled by pre-filter
   - Soft constraint: daily macros within tolerance (implemented as bounds)

4. **Objective function (maximize):**
   - Sum of: recipe_score * x[recipe_id, day, meal_type]
   - recipe_score = 10 for liked recipes, 1 for neutral (binary scoring per CONTEXT.md)

5. **Constraints:**
   - Each recipe used at most once (variety) - allow 1 repeat if fewer liked recipes
   - Meal type matching: breakfast recipes for breakfast, etc.
   - Daily macro bounds: calories ±10%, protein ±10%, etc.

6. **Solve with timeout:**
   - Set solver time limit to `timeout_seconds`
   - If infeasible, return with `fallback_reason: "constraints_infeasible"`
   - If timeout, return with `fallback_reason: "timeout"`

7. **Quality check (per CONTEXT.md):**
   - Calculate liked_ratio: count of liked recipes in solution / 21
   - Calculate macro_deviation: max deviation from targets
   - If liked_ratio < 0.5 or macro_deviation > 0.2: return `fallback_reason: "quality_threshold"`

8. **Format output:**
   - Convert solution to same structure as `_build_weekly_plan` in planner.py
   - Include recipe details (id, name, calories, protein, carbs, fat, instructions, ingredients)

**Helper functions to create:**
- `_get_user_ratings(db, user_id)` -> tuple of (liked_ids set, disliked_ids set)
- `_get_last_week_recipes(db, user_id)` -> set of recipe IDs from most recent plan
  - Implementation: query Preference for user_id with plan_status="success", order by submitted_at DESC, limit 1
  - If found, query PlanRecipe where preference_id = that preference.id
  - Return set of recipe_ids from those PlanRecipe entries
- `_filter_recipes_for_solver(db, preference, disliked_ids, last_week_ids)` -> DataFrame
- `_check_impossible_constraints(df, macro_targets, dietary_restrictions)` -> Optional error message
- `_build_solver_model(df, liked_ids, macro_targets, meal_slots)` -> PuLP model
- `_extract_solution(model, df, recipe_vars)` -> list of selected recipes per (day, meal_type)
- `_calculate_quality_metrics(solution, liked_ids, macro_targets)` -> dict

**Dietary restriction mapping:**
Map preference dietary_restrictions to recipe filtering:
- "vegan" -> recipe.dietary_flags.get("is_vegan") == True
- "vegetarian" -> recipe.dietary_flags.get("is_vegetarian") == True OR is_vegan
- "gluten_free" -> "gluten" not in recipe.allergens
- "dairy_free" -> "dairy" not in recipe.allergens
- "nut_free" -> "nuts" not in recipe.allergens AND "tree nuts" not in allergens

**Meal type detection:**
Use recipe.meal_type field:
- "breakfast" -> meal_type == "breakfast"
- "lunch" -> meal_type == "lunch"
- "dinner" -> meal_type == "dinner" OR meal_type is None (default to dinner)
  </action>
  <verify>
Run `python -c "from solver import generate_personalized_plan; print('Import successful')"` from Backend/fastapi_app directory
  </verify>
  <done>
Solver module exists with generate_personalized_plan function that:
- Loads user ratings and last week's recipes
- Pre-filters recipe pool to valid candidates
- Builds and solves PuLP optimization model
- Returns plan in same format as OpenAI planner OR error/fallback_reason
  </done>
</task>

</tasks>

<verification>
After completing all tasks:

1. Import test: `python -c "from solver import generate_personalized_plan"`
2. Code review checklist:
   - [ ] Dietary restrictions are hard constraints (recipes violating are excluded)
   - [ ] Macro tolerance is ±10% (configurable)
   - [ ] Quality threshold: <50% liked OR >20% macro deviation triggers fallback
   - [ ] Last week's recipes are excluded
   - [ ] Timeout is respected (solver time limit)
   - [ ] Output format matches planner.py structure
</verification>

<success_criteria>
- solver.py module exists with documented functions
- PuLP listed in requirements.txt
- Module can be imported without errors
- Function signature matches specification
- Code handles edge cases (no liked recipes, impossible constraints)
</success_criteria>

<output>
After completion, create `.planning/phases/07-constraint-solver-engine/07-01-SUMMARY.md`
</output>
