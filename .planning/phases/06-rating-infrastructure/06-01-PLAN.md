---
phase: 06-rating-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Backend/fastapi_app/models.py
  - Backend/fastapi_app/main.py
autonomous: true

must_haves:
  truths:
    - "User can submit a like or dislike rating for a recipe in their plan"
    - "User can change their rating from like to dislike or vice versa"
    - "User can view their rating count toward personalization threshold"
    - "System tracks which recipes appeared in which plans and when"
    - "Ratings persist across sessions"
  artifacts:
    - path: "Backend/fastapi_app/models.py"
      provides: "Rating and PlanRecipe models"
      contains: "class Rating"
    - path: "Backend/fastapi_app/main.py"
      provides: "Rating API endpoints"
      exports: ["POST /ratings", "GET /ratings/me", "GET /ratings/progress"]
  key_links:
    - from: "POST /ratings"
      to: "Rating model"
      via: "SQLAlchemy insert/upsert"
      pattern: "db\\.add\\(Rating"
    - from: "GET /ratings/progress"
      to: "Rating model"
      via: "count query"
      pattern: "func\\.count.*Rating"
---

<objective>
Build the backend infrastructure for recipe ratings and plan-recipe tracking.

Purpose: Enable users to rate meals (like/dislike) and track which recipes appeared in generated plans, laying the foundation for personalized recommendations.

Output:
- Rating model with user_id, recipe_id, is_liked, created_at, updated_at
- PlanRecipe model linking preferences to recipes with meal metadata
- API endpoints for submitting ratings, fetching user ratings, and progress toward personalization
</objective>

<execution_context>
@/Users/pasha/.claude/get-shit-done/workflows/execute-plan.md
@/Users/pasha/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@Backend/fastapi_app/models.py
@Backend/fastapi_app/main.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Rating and PlanRecipe database models</name>
  <files>Backend/fastapi_app/models.py</files>
  <action>
Add two new SQLAlchemy models to models.py:

1. **Rating model:**
   - id: UUID primary key (default uuid4)
   - user_id: UUID foreign key to users.id (not null)
   - recipe_id: UUID foreign key to recipes.id (not null)
   - is_liked: Boolean (not null) - True=like, False=dislike
   - created_at: DateTime with timezone (server_default=func.now())
   - updated_at: DateTime with timezone (server_default=func.now(), onupdate=func.now())
   - Add unique constraint on (user_id, recipe_id) to ensure one rating per user per recipe
   - Add relationship to User and Recipe

2. **PlanRecipe model:**
   - id: UUID primary key (default uuid4)
   - preference_id: Integer foreign key to preferences.id (not null)
   - recipe_id: UUID foreign key to recipes.id (not null)
   - day_name: String(16) (e.g., "Monday")
   - meal_type: String(16) (e.g., "breakfast", "lunch", "dinner", "snack")
   - created_at: DateTime with timezone (server_default=func.now())
   - Add index on (preference_id) for efficient lookups

Import UniqueConstraint from sqlalchemy for the Rating model.
  </action>
  <verify>
Run: python -c "from models import Rating, PlanRecipe; print('Models imported successfully')"
  </verify>
  <done>
Rating model exists with user_id, recipe_id, is_liked fields and unique constraint.
PlanRecipe model exists with preference_id, recipe_id, day_name, meal_type fields.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add rating API endpoints</name>
  <files>Backend/fastapi_app/main.py</files>
  <action>
Add the following to main.py:

1. **Pydantic models:**
   - RatingCreate: recipe_id (UUID), is_liked (bool)
   - RatingResponse: id, user_id, recipe_id, is_liked, created_at, updated_at
   - RatingProgressResponse: total_ratings (int), threshold (int), is_unlocked (bool)
   - RatingListResponse: items (list[RatingResponse]), pagination (AdminPagination)

2. **POST /ratings endpoint:**
   - Requires current_user_dependency
   - Accepts RatingCreate body
   - Validates recipe_id exists and is_active
   - Upserts rating (update if exists, create if not)
   - Returns RatingResponse
   - Performance: Use single query with ON CONFLICT for upsert

3. **GET /ratings/me endpoint:**
   - Requires current_user_dependency
   - Returns paginated list of user's ratings (limit/offset query params)
   - Order by updated_at desc
   - Returns RatingListResponse

4. **GET /ratings/progress endpoint:**
   - Requires current_user_dependency
   - Returns count of user's ratings vs threshold (10)
   - Returns RatingProgressResponse with is_unlocked=True when count >= 10

Import Rating model at top. Add log_activity calls for rating_created and rating_updated actions.
  </action>
  <verify>
Run backend with: cd Backend/fastapi_app && uvicorn main:app --reload --port 8000
Test endpoints exist: curl -s http://localhost:8000/openapi.json | grep -E '"\/ratings'
  </verify>
  <done>
POST /ratings creates/updates rating and returns RatingResponse.
GET /ratings/me returns paginated user ratings.
GET /ratings/progress returns rating count and unlock status.
  </done>
</task>

<task type="auto">
  <name>Task 3: Track recipes in generated plans</name>
  <files>Backend/fastapi_app/main.py</files>
  <action>
Modify the plan generation flow to record which recipes are included:

1. **Update _persist_plan_result function:**
   After storing the plan in raw_data, extract recipe IDs from the plan and create PlanRecipe entries.

   Parse plan structure:
   - plan["days"] is a list of day objects
   - Each day has "meals" dict with keys "Breakfast", "Lunch", "Dinner", "Snacks"
   - Each meal has "id" field (recipe UUID)

   For each recipe found:
   - Create PlanRecipe with preference_id, recipe_id, day_name (day["name"]), meal_type (lowercase key)
   - Skip if recipe_id is None or not a valid UUID

   Import PlanRecipe model at top.

2. **Add GET /plans/history endpoint:**
   - Requires current_user_dependency
   - Query user's preferences joined with PlanRecipe
   - Return list of plans with their recipes grouped by preference_id
   - Include preference submitted_at, plan_status, and list of {recipe_id, day_name, meal_type}
   - Paginated with limit/offset (default limit=10)

This enables HIST-01 through HIST-03 requirements.
  </action>
  <verify>
Import check: python -c "from main import PlanRecipe; print('OK')"
Endpoint exists: curl -s http://localhost:8000/openapi.json | grep -E '"\/plans\/history'
  </verify>
  <done>
Generated plans automatically create PlanRecipe entries linking recipes to preferences.
GET /plans/history returns user's meal plan history with recipe tracking.
  </done>
</task>

</tasks>

<verification>
After all tasks:
1. Database models import without error
2. All three rating endpoints appear in OpenAPI spec
3. /plans/history endpoint appears in OpenAPI spec
4. Activity logs track rating events

Manual verification (optional):
- Create a rating via POST /ratings with valid recipe_id
- Retrieve ratings via GET /ratings/me
- Check progress via GET /ratings/progress
</verification>

<success_criteria>
- Rating model with unique constraint on (user_id, recipe_id) exists
- PlanRecipe model with preference/recipe linkage exists
- POST /ratings creates or updates a rating in <1 second (PERF-01)
- GET /ratings/me returns user's rating history
- GET /ratings/progress shows count toward 10-rating threshold
- GET /plans/history returns user's meal plan history
- Concurrent rating submissions handled gracefully via upsert (DATA-04)
</success_criteria>

<output>
After completion, create `.planning/phases/06-rating-infrastructure/06-01-SUMMARY.md`
</output>
